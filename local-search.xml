<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>💻我与Linux的故事</title>
    <link href="/%E9%9A%8F%E7%AC%94/linux_story/"/>
    <url>/%E9%9A%8F%E7%AC%94/linux_story/</url>
    
    <content type="html"><![CDATA[<h1 id="💻-我与-Linux-的故事"><a href="#💻-我与-Linux-的故事" class="headerlink" title="💻 我与 Linux 的故事"></a>💻 我与 Linux 的故事</h1><p>目前我最常使用的操作系统是 Linux，除了玩游戏和一些特殊文档编辑以及阅读论文等需要切换到 Windows，剩下的时间都是在用 Linux。</p><p>Linux 陪伴了我很长时间，曾为他而折腾不休，这篇文章就来讲讲我与 Linux 之间相爱相杀的故事。</p><h2 id="🙆-初遇"><a href="#🙆-初遇" class="headerlink" title="🙆 初遇"></a>🙆 初遇</h2><p>第一次接触 Linux 是在 2018 年春，那一年我大二。一次偶然的机会我打开了 Deepin 深度操作系统的官方网页，那一刻我被 Deepin 的操作界面吸引住了，才知道操作系统原来可以这么漂亮。这是我第一次了解到 Linux。</p><p><img src="/img/linux_story/mmexport1603181259205.png" alt="Deepin"></p><p>2018 年末，我终于在自己的电脑成功安装上 Deepin，第一次使用的感觉其实说实话并不是那么得好用。由于使用 Windows 的习惯，安软件都安不上，只能在应用商店里面找应用，而且软件也都不是最新版的，可以说那次的体验是极差的，但我也使用了一段时间，学习了一些 Linux 的基本知识，用它来写写爬虫啥的（那时候对爬虫挺感兴趣），当时使用的 IDE 是 Sublime Text。</p><h2 id="🐣-启蒙"><a href="#🐣-启蒙" class="headerlink" title="🐣 启蒙"></a>🐣 启蒙</h2><p>转眼到了 2020 年，这一年是我对 Linux 正式进行探索的开始。从这一年我对 Linux 的认知发生了很大的变化，可能我对 Linux 有缘分，我突然觉得在 Linux 下编程是一件很容易的事情，对比反而觉得在 Windows 下编程很复杂，因为 Linux 的文件系统在我看来十分的简洁（一切都从“&#x2F;”开始的文件结构，不像 Windows 的各种盘符和反斜杠），我开始逐渐理解了 Linux 的思想极其设计理念，感觉这才是真正的操作系统。同时这一年经过学习也知道了原来 Linux 是有很多的发行版的，每个发行版也各具特色，选择一款适合自己的 Linux 是一件很重要的事情，于是我展开了对 Linux 的探索之路。这段时间我使用的 IDE 是 VSCode。</p><p><img src="/img/linux_story/272705903.jpg" alt="考研期间"></p><p>我喜欢刷 B 站，一次偶然我刷到了 <a href="https://space.bilibili.com/13081489?spm_id_from=333.337.0.0">TheCW</a> 的视频，这才彻底打开了我对 Linux 的兴趣阀门。CW 大佬的视频给我展示了许多我未曾见到过的 Linux 操作，让我见识到了 Linux 的另一面。在他的视频中我认识到了 Manjaro 和 Arch 等操作系统以及许许多多的开源工具，如 ranger、vim、zsh、git 等，简直颠覆了我对以往 Linux 的认知，原来这才是 Linux 应有的样子。那段时间我经常反复看他的视频学习，也跟着它学习安装操作系统，学着自己解决问题，IDE 也从 VSCode 逐渐过渡到了 Vim。我也尝试了许多其他的 Linux 发行版如 Ubuntu、Manjaro、Mint 甚至地狱级别的 Arch（其实也不算多难），学着配置自己的操作系统，搭建属于自己的环境，将自己的配置文件保存到 Github 上，那时我觉得 Linux 是神一样的存在。那段时间 CW 的视频更新也很频繁，每一期我都会看，那时候自己的技术也不是很扎实，装好的 Arch 经常一遇到问题就重装系统，装了又卸（顺便提一嘴，我安装 Arch 的最短纪录为 30 分钟），其实后来才知道如果系统遇到的问题其实都是大部分不需要重装系统去解决的 😂。自我估计到目前为止我装系统的次数不下一百次，在装系统的过程中我也学到了很多的知识。</p><p>那段时间我一直模仿 CW 大佬的配置，使用 Arch 作为自己的 Linux，后来由于考研的原因就停止学习了一段时间。</p><h2 id="🌿-发芽"><a href="#🌿-发芽" class="headerlink" title="🌿 发芽"></a>🌿 发芽</h2><p>这一阶段是我对 Linux 有了自己的见解。</p><p>时间来到 2021 年，考研结束的我有开始了折腾 Linux，这是的我对 Linux 逐渐开始有了系统性的认识，一些常规的命令都会操作，也开始逐渐完善自己的配置文件。为了向极客靠拢（为了装逼），我开始学习 Vim 以及如何配置插件，当然配置的不很到位。这段时间我使用的还是 Arch，偶尔换到 Manjaro 上面，Arch 的自由度非常高，他不同于其他的 Linux 发行版，Arch 可以说是个 DIY 性质的 Linux，他不会预装多余的软件，安装好它之后只是一个不断闪烁的命令提示符，没有其他多余的东西，用户可以再此基础上安装自己想装的桌面环境，那时我主要在 Gnome 和 KDE 桌面反复横跳，期间也尝试一些小众的桌面管理器如 i3 和 dwm。</p><p><img src="/img/linux_story/972360775.jpg" alt="Arch"></p><p><img src="/img/linux_story/1274666153.jpg" alt="DWM"></p><p>因为各有各的优点不知选哪一个好 😂，由此我也展开了长达一年半多的 Linux 美化之路（这是个坑，千万别跳进来）。我承认自己是条颜狗，喜欢漂亮的东西，操作系统也不例外，经常是装了 Gnome 配置不好又贪恋 KDE，换到 KDE 又思念 Gnome 的简洁高效，来回反复了折腾无数次，说多了都是泪。</p><p>Arch 作为最能折腾的操作做系统我也玩了将近一年，后来认识到该邪教（在 Linux 发行版圈子里，其他发行版都称 Arch 为邪教组织）的真实模样，我来给大家总结一下：</p><ol><li>Arch 的软件包是我见过最多的 Linux 发行版，尤其是 aur，几乎没有搜不到的软件。</li><li>Arch Linux 确实是一个不错的 Linux 发行版，他属于滚动更新的，即所有的包都会是最新版的版本，这就给它带来不稳定的因素，比如长时间不更新容易滚挂的风险，我可不想使用用着用着就会挂掉的系统，我需要一个稳定的操作系统。</li><li>Arch 配置起来很麻烦，一切都是从头开始配置自己的系统，做不到开箱即用，甚是折腾，对于忙于学业的我来说这会耗费极大的时间和精力。</li></ol><p><img src="/img/linux_story/IMG_20210419_102132.jpg" alt="没有图形界面的Arch"></p><p>后来因为逐渐意识到 Arch 不适合自己，但又想体验 Arch 丰富的软件，于是我退而求其次试用起了 Manjaro，Manjaro 是基于 arch 开发的 Linux 发行版，能够做到开箱即用，说白了就是将 Arch 向其他 Linux 发行版一样图形化安装，又能体验到 Arch 的所有好处的一款系统。Manjaro 我一直用到入学，用了一段时间感觉除了图标难看以为其他都还是不错的。显卡驱动配置起来也是很方便，但时间长了问题也来了，开机有时候会概率性的黑屏卡住，本以为找到一款完美 Linux 的我瞬间不开心了，其实 Manjaro 对显卡的支持并不是很好，由于研究生研究的方向与深度学习相关需要用到 GPU，能找到一款完美支持显卡驱动的 Linux 是我当务之急，于是我放弃了 Manjaro，又开始了新的探索。</p><h2 id="😕-迷茫"><a href="#😕-迷茫" class="headerlink" title="😕 迷茫"></a>😕 迷茫</h2><p>2021 下半年研究生入学，怀着对新学校的憧憬我来到了一个新的环境，也认识了很多朋友。大家对我使用的 Linux 也感到了些许的好奇之心，他们都在问我使用的是什么操作系统，我也热情的给他们细心的去讲解，但大家往往只是一听而过而并未做过多的深入，我也就不再多说。</p><p>Manjaro 我是不再考虑了，每次开机玄学卡住。于是 Linux Mint 和 openSUSE 开始引起我的注意，经过使用之后发现他们极其的稳定，且都对显卡驱动支持很好。Linux Mint 是基于 Ubuntu 的发行版，使用 apt 作为包管理工具，软件的支持也很好。openSUSE 是一款比较小众的 Linux，有自己独立的软件仓库，界面使用 Gnome，配置好之后非常美观，就是有一个缺点，缺包，安装一些第三方软件有时会提示缺少库文件，我也尝试过去补包但有几个始终补不上，后来就不了了之，用起了 Mint。</p><p>这段时间我也花了大量时间去美化桌面，包括 Opensuse 和 Mint。后来由于意识到花在这上面的时间太多，就不再美化了，使用 Mint 默认的原生桌面。</p><p><img src="/img/linux_story/IMG_20220207_000016.jpg" alt="即便是Mint我也配置成Mac的界面"></p><p>到了研一寒假我基本上不再搞美化了，全身心投入到技能的提高上面，因此节省出来了大量的时间可以让我配置 Vim 插件以及读论文。这段时间也是我对前端感兴趣的开始。</p><p>由于本人英文很差，看论文需要翻译软件才能看得懂，而在我们研究生之间流传深广的翻译软件是一款名叫 <a href="https://www.zhiyunwenxian.cn/">知云</a> 的文献翻译软件，很可惜他只能在 Windows 和 Mac 平台有才有发布，唯独忽略了我最钟爱的 Linux，这使得我不得不切换到 Windows 下看论文，也十分的麻烦。之前在 Github 上有位大佬写过一个全平台的翻译软件 <a href="https://github.com/CopyTranslator/CopyTranslator">CopyTranslator</a>，由于很长时间没有维护，现在基本上在 Linux 平台上不能使用了，于是我萌生了自己写一款全平台的文献翻译软件，这个后续再讲，先挖个坑。</p><p>Linux Mint 确实不错，包全、稳定、显卡支持好就是界面朴素了些（Mint 使用 cinnamon 桌面环境，样子和 Windows 差不多）。但不得不说它是也个很不错的 Linux 发行版，十分推荐给初学者使用 Linux（Ubuntu 我是真的不想推荐）。但后来由于想念 Gnome 桌面的那种丝滑的切换和好看的界面，我又开始蠢蠢欲动了，又想着寻找一款完美的 Linux，我梦想中的 Linux 有一下要求：</p><ol><li>系统稳定，不是滚动更新</li><li>界面美观</li><li>包全</li><li>支持显卡驱动</li></ol><h2 id="🌟-曙光"><a href="#🌟-曙光" class="headerlink" title="🌟 曙光"></a>🌟 曙光</h2><p>由于实在想要一款完美的操作系统，开学之后我将 Mint 换掉了，又开始了无休止的重装系统。这段时间我锁定了 Fedora 这款 Linux，他默认的桌面系统就是 Gnome，是属于红帽系列的 rpm 包作为通用的包格式管理。印象当中红帽系列的 Linux 很稳定，很适合作为服务器来使用，这就对他有了一个刻板印象，就是一直以为红帽 Linux 的包很旧，包少。</p><p>在安装上 Fedora 上之后我发现并不是这样，相反 Fedora 的更新频率很高有很稳定，几乎满足了我对完美 Linux 的前三条。之前也有用过 Fedora，看着别人在 CSDN 上写的教程尝试安装显卡驱动却都以失败告终，这次安装驱动我不再去看 CSDN 了，按照 <a href="https://docs.fedoraproject.org/en-US/quick-docs/how-to-set-nvidia-as-primary-gpu-on-optimus-based-laptops/">Fedora 的官方文档</a>去安，结果居然安装成功。这正是我梦寐以求的完美 Linux，终于被我找到了。这也让我知道了看官方文档的重要性。</p><p><img src="/img/linux_story/fedora.png" alt="如今我使用的Fedora"></p><h2 id="💡-后续"><a href="#💡-后续" class="headerlink" title="💡 后续"></a>💡 后续</h2><p>后续的日子我一直在使用 Fedora，有时为了打游戏和一些必要的文档编辑需要切换到 Windows，所以其实我更愿称 Windows 为游戏系统。</p><p>这就是我与 Linux 的故事，从开始的懵懂到如今的操作娴熟都透露出我对 Linux 开源社区的热爱。以后我会陆续发几篇文章来告诉大家为什么为什么我推荐 Linux 以及它和 Windows 之间的区别是什么，先挖个坑。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vim】Vim的基本使用</title>
    <link href="/Vim/vim_use/"/>
    <url>/Vim/vim_use/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-Vi-x2F-Vim"><a href="#Linux-Vi-x2F-Vim" class="headerlink" title="Linux Vi&#x2F;Vim"></a>Linux Vi&#x2F;Vim</h2><p>所有的 Unix Like 系统都会内建 Vi 文书编辑器，其他的文书编辑器则不一定会存在。<br>在 GNU 项目中，程序员在将 Vi 编辑器移植到开源世界的同时，决定对其作一些改进。<br>由于改进后的 Vi 不再是以前 Unix 中的那个原始的 Vi 编辑器了，开发人员也就将它重命名为“Vi improved”，也就是 Vim。<br>但是目前我们使用比较多的是 Vim 编辑器。Vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><h2 id="什么是-Vim"><a href="#什么是-Vim" class="headerlink" title="什么是 Vim"></a>什么是 Vim</h2><p>Vim 是从 Vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和 Emacs 并列成为类 Unix 系统用户最喜欢的文本编辑器。</p><p>简单的来说， Vi 是老式的字处理器，功能已经很齐全了，但是还是有可以进步的地方。 Vim 则可以说是程序开发者的一项很好用的工具。</p><p><strong>Vim 键位图:</strong><br><img src="/img/vim_use/vi-vim.gif" alt="Vim 键位图"></p><p>看起来是不是很复杂？不用担心，但其实常用的也就那么几个，而且命令之间也很具有逻辑性，非常好记。</p><h2 id="Vim-的使用"><a href="#Vim-的使用" class="headerlink" title="Vim 的使用"></a>Vim 的使用</h2><p>基本上 Vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p><p><strong>命令模式</strong><br>命令模式就是刚刚进入 Vim 的时候默认的模式。</p><p>此时如果敲击键盘会被识别为命令。以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p><strong>输入模式</strong><br>在命令模式下按下 i 就进入了输入模式。<br>在输入模式中，可以使用以下按键：</p><ul><li>字符按键以及 Shift 组合，输入字符</li><li>ENTER，回车键，换行</li><li>BACKSPACE，退格键，删除光标前一个字符</li><li>DEL，删除键，删除光标后一个字符</li><li>方向键，在文本中移动光标</li><li>HOME&#x2F;END，移动光标到行首&#x2F;行尾</li><li>Page Up&#x2F;Page Down，上&#x2F;下翻页</li><li>Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li><li>ESC，退出输入模式，切换到命令模式</li></ul><p><strong>底线命令模式</strong><br>在命令模式下按下:（英文冒号）就进入了底线命令模式。<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li><strong>q</strong> 退出程序</li><li><strong>w</strong> 保存文件</li></ul><p>按 ESC 键可随时退出底线命令模式。<br>简单的说，我们可以将这三个模式想成底下的图标来表示：<br><img src="/img/vim_use/vim_work_mode.png" alt="Vim 的三种工作模式"></p><h2 id="Vim-的按键说明"><a href="#Vim-的按键说明" class="headerlink" title="Vim 的按键说明"></a>Vim 的按键说明</h2><p>以上只是基本操作，还有许多的命令可以学习，并且很具有逻辑性。</p><h3 id="第一部分-一般模式可用的光标移动、选择复制粘贴、搜索替换等"><a href="#第一部分-一般模式可用的光标移动、选择复制粘贴、搜索替换等" class="headerlink" title="第一部分 一般模式可用的光标移动、选择复制粘贴、搜索替换等"></a>第一部分 一般模式可用的光标移动、选择复制粘贴、搜索替换等</h3><h4 id="移动光标的方法"><a href="#移动光标的方法" class="headerlink" title="移动光标的方法"></a>移动光标的方法</h4><table><thead><tr><th align="center">按键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">h 或 向左箭头键(←) 或 [backspace]</td><td align="center">光标向左移动一个字符</td></tr><tr><td align="center">j 或 向下箭头键(↓) 或 [enter]</td><td align="center">光标向下移动一个字符</td></tr><tr><td align="center">k 或 向上箭头键(↑)</td><td align="center">光标向上移动一个字符</td></tr><tr><td align="center">l 或 向右箭头键(→) 或 [space]</td><td align="center">光标向右移动一个字符</td></tr><tr><td align="center">[Ctrl] + [f]</td><td align="center">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [b]</td><td align="center">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="center">[Ctrl] + [d]</td><td align="center">屏幕『向下』移动半页</td></tr><tr><td align="center">[Ctrl] + [u]</td><td align="center">屏幕『向上』移动半页</td></tr><tr><td align="center">0 或功能键[Home]</td><td align="center">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="center">$ 或功能键[End]</td><td align="center">移动到这一行的最后面字符处(常用)</td></tr><tr><td align="center">H</td><td align="center">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="center">M</td><td align="center">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="center">L</td><td align="center">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="center">G</td><td align="center">移动到这个档案的最后一行(常用)</td></tr><tr><td align="center">nG</td><td align="center">n 为数字。移动到这个档案的第 n 行。</td></tr><tr><td align="center">gg</td><td align="center">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="center">n[Enter]</td><td align="center">n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><blockquote><p>如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！<br>其实很多的命令只要先加数字都可以实现类似的功能。比如删除命令<code>dd</code>，要想删除下两行，可以使用<code>2dd</code>。</p></blockquote><h4 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h4><table><thead><tr><th align="center">按键</th><th>作用</th></tr></thead><tbody><tr><td align="center">&#x2F;word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="center">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">n</td><td>重复前一个<strong>搜寻</strong>的动作。</td></tr><tr><td align="center">N</td><td>与 n 刚好相反，为『反向』进行前一个<strong>搜寻</strong>动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr></tbody></table><blockquote><p>使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</p></blockquote><h4 id="选择、删除、复制与粘贴"><a href="#选择、删除、复制与粘贴" class="headerlink" title="选择、删除、复制与粘贴"></a>选择、删除、复制与粘贴</h4><table><thead><tr><th align="center">按键</th><th>作用</th></tr></thead><tbody><tr><td align="center">v</td><td>进入按字符选择模式,通过 h、i、j、k 键移动光标选择要进行复制的字符串</td></tr><tr><td align="center">V</td><td>进入按行选择模式，通过 h、i、j、k 键移动光标选择要进行复制的行号</td></tr><tr><td align="center">[Ctrl]+v</td><td>进入到按块选择模式，通过 h、i、j、k 移动鼠标选择要进行复制的区域块</td></tr><tr><td align="center">x</td><td>向后删除一个字符 (相当于 [del] 按键)。</td></tr><tr><td align="center">X</td><td>向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="center">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="center">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="center">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="center">d1G 或 dgg</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="center">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="center">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="center">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="center">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="center">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="center">y1G 或 ygg</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="center">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="center">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="center">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="center">p</td><td>将已复制的数据在光标下一行贴上</td></tr><tr><td align="center">P</td><td>将已复制的数据在光标上一行贴上</td></tr><tr><td align="center">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="center">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="center">u</td><td><strong>撤销</strong>上一步的操作。(常用)</td></tr><tr><td align="center">[Ctrl]+r</td><td><strong>重做（前进）</strong>上一个动作。(常用)</td></tr><tr><td align="center">.</td><td>这是就是小数点。表示重复前一个动作。如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><blockquote><p>u 与 [Ctrl]+r 是很常用的指令，表示前进和后退。另外「.」这个指令表示重复刚刚的动作，也非常常用。</p></blockquote><h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><thead><tr><th align="center">按键</th><th>作用</th></tr></thead><tbody><tr><td align="center">i, I</td><td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="center">a, A</td><td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="center">o, O</td><td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td align="center">r, R</td><td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="center">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><h4 id="指令行的储存、离开等指令"><a href="#指令行的储存、离开等指令" class="headerlink" title="指令行的储存、离开等指令"></a>指令行的储存、离开等指令</h4><table><thead><tr><th align="center">按键</th><th>作用</th></tr></thead><tbody><tr><td align="center">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="center">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td align="center">:q</td><td>离开 vim (常用)</td></tr><tr><td align="center">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="center">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="center">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td align="center">ZQ</td><td>不保存，强制退出。效果等同于 :q!。</td></tr><tr><td align="center">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="center">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="center">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="center">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！</td></tr></tbody></table><blockquote><p>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</p></blockquote><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><h3 id="批量注释"><a href="#批量注释" class="headerlink" title="批量注释"></a>批量注释</h3><p>[Ctrl] + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 &#x2F;&#x2F; 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p><p>取消注释：</p><p>[Ctrl] + v 进入块选择模式，选中你要删除的行首的注释符号，注意 &#x2F;&#x2F; 要选中两个，选好之后按 d 即可删除注释，ESC 保存退出。</p><blockquote><p>本文参考：<a href="https://www.runoob.com/linux/linux-vim.html">菜鸟编程 Linux vi&#x2F;vim</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】SSH的基本使用</title>
    <link href="/Linux/ssh_use/"/>
    <url>/Linux/ssh_use/</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在 Linux 系统上 SSH 是非常常用的工具，通过 SSH Client 我们可以连接到运行了 SSH Server 的远程机器上。SSH Client 的基本使用方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh user@remote -p port<br></code></pre></td></tr></table></figure><ul><li>user 是你在远程机器上的用户名，如果不指定的话默认为当前用户</li><li>remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名</li><li>port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22</li></ul><p>在执行了 ssh 命令之后，远程机器会询问你的密码。在输入密码的时候，屏幕上不会显示明文密码，也不会显示 ******，这样别人就不会看到你的密码长度了，按下回车即可登入。</p><p>登入之后，就可以远程控制机器啦！</p><h2 id="安装-OpenSSH-Server"><a href="#安装-OpenSSH-Server" class="headerlink" title="安装 OpenSSH Server"></a>安装 OpenSSH Server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">local</span>$ ssh user@remote -p port<br>ssh: connect to host remote port 22: Connection refused<br></code></pre></td></tr></table></figure><p>如果你遇到了上面的消息，说明在远程机器上没有安装 SSH Server，特别地，如果远程机器运行的是 Ubuntu Desktop 系统，那么默认是没有安装 SSH Server 的。这个时候，你可以联系管理员让他安装 SSH Server，或者如果你有 sudo 权限的话，可以执行下面命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install openssh-server<br></code></pre></td></tr></table></figure><p>相应的本地机器需要执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install openssh-client<br></code></pre></td></tr></table></figure><h2 id="免密码登入"><a href="#免密码登入" class="headerlink" title="免密码登入"></a>免密码登入</h2><p>在本地机器输入下面指令生成 SSH 钥匙，一路回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen<br></code></pre></td></tr></table></figure><p>输出的内容告诉了我们，生成的公钥放在了 ~&#x2F;.ssh&#x2F;id_rsa.pub，私钥放在了 ~&#x2F;.ssh&#x2F;id_rsa。接下来，我们要让远程机器记住我们的公钥。最简单的方法是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-copy-id user@remote -p port<br></code></pre></td></tr></table></figure><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p>每次都输入 ssh user@remote -p port，时间久了也会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆的时候。配置别名可以让我们进一步偷懒。</p><p>比如我想用 ssh lab 来替代上面这么一长串，那么在 ~&#x2F;.ssh&#x2F;config 里面追加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host lab<br>    HostName remote<br>    User user<br>    Port port<br></code></pre></td></tr></table></figure><p>保存之后，即可用 ssh lab 登入，如果还配置了公钥登入，那就连密码都不用输入了。</p><h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2><p>在两台机之间传输文件可以用 scp，它的地址格式与 ssh 基本相同，都是可以省略用户名和端口，稍微的差别在与指定端口时用的是大写的 -P 而不是小写的。不过，如果你已经配置了别名，那么这都不重要，因为 scp 也支持直接用别名。scp 用起来很简单，看看下面的例子就明白了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 把本地的 /path/to/local/file 文件传输到远程的 /path/to/remote/file</span><br>scp -P port /path/to/local/file user@remote:/path/to/remote/file<br><br><span class="hljs-comment"># 也可以使用别名</span><br>scp /path/to/local/file lab:/path/to/remote/file<br><br><span class="hljs-comment"># 把远程的 /path/to/remote/file 下载到本地的 /path/to/local/file</span><br>scp lab:/path/to/remote/file /path/to/local/file<br><br><span class="hljs-comment"># 远程的默认路径是家目录</span><br><span class="hljs-comment"># 下面命令把当前目录下的 file 传到远程的 ~/dir/file</span><br>scp file lab:<span class="hljs-built_in">dir</span>/file<br><br><span class="hljs-comment"># 加上 -r 命令可以传送文件夹</span><br><span class="hljs-comment"># 下面命令可以把当前目录下的 dir 文件夹传到远程的家目录下</span><br>scp -r <span class="hljs-built_in">dir</span> lab:<br><br><span class="hljs-comment"># 别忘了 . 可以用来指代当前目录</span><br><span class="hljs-comment"># 下面命令可以把远程的 ~/dir 目录下载到当前目录里面</span><br>scp -r lab:<span class="hljs-built_in">dir</span>/ .<br></code></pre></td></tr></table></figure><h2 id="保持程序在后台运行"><a href="#保持程序在后台运行" class="headerlink" title="保持程序在后台运行"></a>保持程序在后台运行</h2><p>有时候你想要在远程的机器上跑一个需要长时间运行的程序，比如一些计算，然后当你睡了一觉再登入远程的机子上却发现什么结果都没有。这是因为一旦 ssh 进程退出，所有它之前启动的程序都会被杀死。那么有什么办法可以保持程序在后台运行呢？</p><p>你需要在远程的机子上使用 tmux。tmux 是一个会话管理程序，他会保持程序一直运行着。在 Ubuntu 上你可以通过 sudo apt-get install tmux 来安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">remote$ tmux<br></code></pre></td></tr></table></figure><p>这样你就进入到了 tmux 管理的会话中，之后你再运行任何东西都不会因为你退出 ssh 而被杀死。要暂时离开这个会话，可以先按下 ctrl+b 再按下 d。要恢复之前的会话，只需要执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">remote$ tmux attach<br></code></pre></td></tr></table></figure><p>tmux 还能管理多个窗口、水平竖直切分、复制粘贴等等，你可以看看<a href="https://link.zhihu.com/?target=http://blog.jobbole.com/87584/">这篇不错的文章</a>来入门。</p><p>如果你是 Mac 用户，那么十分幸运的是，你几乎不需要任何学习，只要把你的终端由系统自带的 Terminal 换成 iTerm 2。iTerm 2 自带超好的 tmux 支持，你可以像操作本机的标签页一样操作 tmux 会话。你只需要在新建会话的时候使用 tmux -CC，在恢复的时候使用 tmux -CC attach 即可。具体的可以参见 iTerm2 and tmux Integration。</p><p>最后强调一遍，tmux 应该运行在远程的机子上，而不是本机上，否则程序在 ssh 退出时依然会被杀死。</p><blockquote><p>本文参考：<a href="https://zhuanlan.zhihu.com/p/21999778">SSH 基本用法</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
